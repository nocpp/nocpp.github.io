<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS相关知识 | 干蛋杂货铺</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="记录学到的知识，活到老，学到老">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.fd6f0cf4.css" as="style"><link rel="preload" href="/assets/js/app.3d95d36a.js" as="script"><link rel="preload" href="/assets/js/3.d4f79d98.js" as="script"><link rel="preload" href="/assets/js/1.4877e3be.js" as="script"><link rel="preload" href="/assets/js/8.4fbb2fd7.js" as="script"><link rel="prefetch" href="/assets/js/10.eafd7546.js"><link rel="prefetch" href="/assets/js/11.c1484040.js"><link rel="prefetch" href="/assets/js/12.c2551dd1.js"><link rel="prefetch" href="/assets/js/13.50cbd960.js"><link rel="prefetch" href="/assets/js/14.cf13345e.js"><link rel="prefetch" href="/assets/js/15.60a6175d.js"><link rel="prefetch" href="/assets/js/16.77f74949.js"><link rel="prefetch" href="/assets/js/17.961850e6.js"><link rel="prefetch" href="/assets/js/18.e5a1e9e9.js"><link rel="prefetch" href="/assets/js/19.bf2e33c1.js"><link rel="prefetch" href="/assets/js/20.b9241c48.js"><link rel="prefetch" href="/assets/js/21.f90906b8.js"><link rel="prefetch" href="/assets/js/22.25b8c488.js"><link rel="prefetch" href="/assets/js/23.0042e186.js"><link rel="prefetch" href="/assets/js/24.3277bdf1.js"><link rel="prefetch" href="/assets/js/25.ced3d6c2.js"><link rel="prefetch" href="/assets/js/26.7e3597c1.js"><link rel="prefetch" href="/assets/js/27.4c8d6844.js"><link rel="prefetch" href="/assets/js/28.6ace512d.js"><link rel="prefetch" href="/assets/js/29.844df8e6.js"><link rel="prefetch" href="/assets/js/30.56fcae0d.js"><link rel="prefetch" href="/assets/js/31.c743711c.js"><link rel="prefetch" href="/assets/js/32.a61d938f.js"><link rel="prefetch" href="/assets/js/33.6c449d2a.js"><link rel="prefetch" href="/assets/js/34.81961b15.js"><link rel="prefetch" href="/assets/js/35.2e569f6e.js"><link rel="prefetch" href="/assets/js/36.e97fc834.js"><link rel="prefetch" href="/assets/js/37.1215b439.js"><link rel="prefetch" href="/assets/js/38.cd1fc02a.js"><link rel="prefetch" href="/assets/js/39.695896eb.js"><link rel="prefetch" href="/assets/js/4.ea8e479a.js"><link rel="prefetch" href="/assets/js/40.7fb26723.js"><link rel="prefetch" href="/assets/js/41.873f91e1.js"><link rel="prefetch" href="/assets/js/42.1fe6db7e.js"><link rel="prefetch" href="/assets/js/43.72c15365.js"><link rel="prefetch" href="/assets/js/44.a0e52e26.js"><link rel="prefetch" href="/assets/js/45.23a30860.js"><link rel="prefetch" href="/assets/js/46.95dc73a9.js"><link rel="prefetch" href="/assets/js/47.6e474ded.js"><link rel="prefetch" href="/assets/js/48.cd3a1d0a.js"><link rel="prefetch" href="/assets/js/49.cfeaaae4.js"><link rel="prefetch" href="/assets/js/5.7bcaa0fd.js"><link rel="prefetch" href="/assets/js/50.d96bb9d6.js"><link rel="prefetch" href="/assets/js/51.8022a859.js"><link rel="prefetch" href="/assets/js/52.d01ff759.js"><link rel="prefetch" href="/assets/js/53.e538261c.js"><link rel="prefetch" href="/assets/js/54.09f75820.js"><link rel="prefetch" href="/assets/js/55.9ee00ee3.js"><link rel="prefetch" href="/assets/js/56.94ceb43b.js"><link rel="prefetch" href="/assets/js/57.a92f86fd.js"><link rel="prefetch" href="/assets/js/58.3f338820.js"><link rel="prefetch" href="/assets/js/59.86af531a.js"><link rel="prefetch" href="/assets/js/6.73f6e9bf.js"><link rel="prefetch" href="/assets/js/60.7242c577.js"><link rel="prefetch" href="/assets/js/61.803e0e0d.js"><link rel="prefetch" href="/assets/js/62.961c8198.js"><link rel="prefetch" href="/assets/js/63.4fea8675.js"><link rel="prefetch" href="/assets/js/64.765a0f16.js"><link rel="prefetch" href="/assets/js/65.301cf7bd.js"><link rel="prefetch" href="/assets/js/66.627c35e5.js"><link rel="prefetch" href="/assets/js/67.19170c8e.js"><link rel="prefetch" href="/assets/js/7.b2345f7b.js"><link rel="prefetch" href="/assets/js/9.a4f4b980.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fd6f0cf4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>干蛋杂货铺</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>记录学到的知识，活到老，学到老</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">干蛋杂货铺</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-date"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/实战/" class="nav-link"><i class="undefined"></i>
  实战
</a></li><li class="dropdown-item"><!----> <a href="/categories/数据结构/" class="nav-link"><i class="undefined"></i>
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/categories/javascript/" class="nav-link"><i class="undefined"></i>
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/categories/设计模式/" class="nav-link"><i class="undefined"></i>
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/categories/杂项/" class="nav-link"><i class="undefined"></i>
  杂项
</a></li><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/categories/vue/" class="nav-link"><i class="undefined"></i>
  vue
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="./avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <!----> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>54</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>51</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-date"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/实战/" class="nav-link"><i class="undefined"></i>
  实战
</a></li><li class="dropdown-item"><!----> <a href="/categories/数据结构/" class="nav-link"><i class="undefined"></i>
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/categories/javascript/" class="nav-link"><i class="undefined"></i>
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/categories/设计模式/" class="nav-link"><i class="undefined"></i>
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/categories/杂项/" class="nav-link"><i class="undefined"></i>
  杂项
</a></li><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/categories/vue/" class="nav-link"><i class="undefined"></i>
  vue
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>JS相关知识</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">JS相关知识</h1> <div data-v-1ff7123e><!----> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>12/20/2021</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>JS</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="讲讲js的数据类型"><a href="#讲讲js的数据类型" class="header-anchor">#</a> 讲讲JS的数据类型？</h2> <p>最新的 ECMAScript 标准定义了 9种数据类型:</p> <h3 id="_7-种原始类型【primitive】"><a href="#_7-种原始类型【primitive】" class="header-anchor">#</a> 7 种原始类型【primitive】</h3> <ul><li>Boolean</li> <li>Undefined</li> <li>Null</li> <li>Number</li> <li>BigInt  11n,22n这就是这个类型的</li> <li>String</li> <li>Symbol  let s = Symbol()</li></ul> <h3 id="_2-种结构类型"><a href="#_2-种结构类型" class="header-anchor">#</a> 2 种结构类型</h3> <ul><li>Object</li> <li>Function</li></ul> <h2 id="symbol类型"><a href="#symbol类型" class="header-anchor">#</a> Symbol类型</h2> <p>由于ES5中对象属性名都是字符串，有可能造成命名重复，所以ES6提出的Symbol类型解决这个问题。Symbol 值通过Symbol函数生成。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token comment">//第一种写法</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">'Hello!'</span><span class="token comment">//第二种写法</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token string">'Hello!'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第三种写法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1000</span>
window<span class="token punctuation">.</span>s <span class="token comment">//这样不行，不能用点运算符。因为点运算符后面总是字符串</span>

<span class="token keyword">typeof</span> s
<span class="token comment">// &quot;symbol&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p></blockquote> <div class="custom-block danger"><p class="title"></p><p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p></div><h3 id="symbol函数可以接受一个字符串作为参数"><a href="#symbol函数可以接受一个字符串作为参数" class="header-anchor">#</a> Symbol函数可以接受一个字符串作为参数</h3> <p>表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p> <div class="custom-block danger"><p class="title"></p><p>注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

s1 <span class="token comment">// Symbol(foo)</span>
s2 <span class="token comment">// Symbol(bar)</span>

s1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;Symbol(foo)&quot;</span>
s2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;Symbol(bar)&quot;</span>

<span class="token comment">//ES2019 提供description可以读取描述</span>
s1<span class="token punctuation">.</span>description <span class="token comment">// &quot;foo&quot;</span>

<span class="token comment">// 有参数的情况</span>
<span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

s1 <span class="token operator">===</span> s2 <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="如果-symbol-的参数是一个对象"><a href="#如果-symbol-的参数是一个对象" class="header-anchor">#</a> 如果 Symbol 的参数是一个对象</h3> <p>就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
sym <span class="token comment">// Symbol(abc)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="symbol-类型转化"><a href="#symbol-类型转化" class="header-anchor">#</a> Symbol 类型转化</h3> <p>Symbol 值不能与其他类型的值进行运算，会报错，但是可以转为字符串和布尔值，不能转为数值</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s <span class="token operator">+</span> <span class="token string">'abc'</span> <span class="token comment">//会报错</span>
s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//可以</span>
<span class="token function">String</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">//可以</span>
<span class="token function">Boolean</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">//可以</span>
<span class="token operator">!</span>s <span class="token comment">//可以</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="symbol作为属性名被遍历"><a href="#symbol作为属性名被遍历" class="header-anchor">#</a> Symbol作为属性名被遍历</h3> <p>遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。</p> <p>但是，它也不是私有属性，有一个Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

obj<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Hello'</span><span class="token punctuation">;</span>
obj<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'World'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> objectSymbols <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

objectSymbols
<span class="token comment">// [Symbol(a), Symbol(b)]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="异步编程实现方式"><a href="#异步编程实现方式" class="header-anchor">#</a> 异步编程实现方式</h2> <ul><li>回调函数
<ul><li>优点：简单、容易理解</li> <li>缺点：不利于维护，代码耦合高</li></ul></li> <li>事件监听(采用时间驱动模式，取决于某个事件是否发生)【Dom添加事件监听】
<ul><li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li> <li>缺点：事件驱动型，流程不够清晰</li></ul></li> <li>发布/订阅(观察者模式)【pubSub库】
<ul><li>类似于事件监听，但是可以通过‘消息中心‘，了解现在有多少发布者，多少订阅者</li></ul></li> <li>Promise对象
<ul><li>优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；</li> <li>缺点：编写和理解，相对比较难</li></ul></li> <li>Generator函数
<ul><li>优点：函数体内外的数据交换、错误处理机制</li> <li>缺点：流程管理不方便</li></ul></li> <li>async函数
<ul><li>优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。</li> <li>缺点：错误处理机制</li></ul></li></ul> <h2 id="找到a节点的父节点下的所有子节点"><a href="#找到a节点的父节点下的所有子节点" class="header-anchor">#</a> 找到A节点的父节点下的所有子节点</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> b<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span>children<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="encodeuri和encodeuricomponent的比较"><a href="#encodeuri和encodeuricomponent的比较" class="header-anchor">#</a> encodeURI和encodeURIComponent的比较</h2> <ul><li>相同点：都可以对url进行一个编码；</li> <li>encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、下划线、问号和井字号，适用于url跳转时；</li> <li>encodeURIComponent()则会对它发现的任何非标准字符进行编码，适用于有参数要传递时。</li></ul> <blockquote><p>注意：当url作为参数传递时如果没有用encodeURIComponent进行编码，往往会造成传递时url中的特殊字符丢失。</p></blockquote> <h2 id="事件循环【event-loop】"><a href="#事件循环【event-loop】" class="header-anchor">#</a> 事件循环【Event Loop】</h2> <h3 id="event-loop是什么"><a href="#event-loop是什么" class="header-anchor">#</a> Event Loop是什么？</h3> <p>Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是异步的原理</p> <ul><li>事件指的是任务栈完成时，或者异步操作完成时的事件</li> <li>循环指的是，循环检查任务栈是否空，空了就执行任务队列，一直循环
<img src="/assets/img/eventloop.e8a03025.png" alt="event loop"> <img src="/assets/img/eventloop2.9e1d0af7.jpg" alt="event loop2"> <img src="/assets/img/eventloop3.0a7216f7.jpeg" alt="event loop3"> <img src="/assets/img/event_loop4.d6cf12f7.jpg" alt="event loop4"></li></ul> <h3 id="event-loop执行流程"><a href="#event-loop执行流程" class="header-anchor">#</a> Event Loop执行流程</h3> <ol><li>执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</li> <li>全局Script代码执行完毕后，调用栈Stack会清空；</li> <li>从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</li> <li>继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</li> <li>microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</li> <li>取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</li> <li>执行完毕后，调用栈Stack为空；</li> <li>重复第3-7个步骤；</li> <li>重复第3-7个步骤；</li> <li>......</li></ol> <div class="custom-block tip"><p class="title"></p><ul><li>宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；</li> <li>微任务队列中所有的任务都会被依次取出来执行，直到microtask queue为空; 在 UI 重新渲染之前执行，避免了不必要的 UI 渲染。；</li> <li><a href="https://segmentfault.com/a/1190000016278115" target="_blank" rel="noopener noreferrer">参考文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://cloud.tencent.com/developer/article/1533889" target="_blank" rel="noopener noreferrer">腾讯云专栏<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div><h3 id="什么是进程"><a href="#什么是进程" class="header-anchor">#</a> 什么是进程？</h3> <blockquote><p>在传统OS中，进程包含了系统资源和能够独立调度和分派，在创建，撤销和切换过程中要耗费很多时间，为了减少并发的时空开销，提升并发性，引入了线程。把进程分为了多个线程和资源。线程就成为了系统调度和分派的基本单位。（线程的切换代价更低）</p></blockquote> <ul><li>进程是程序的一次执行</li> <li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ul> <h3 id="什么是线程"><a href="#什么是线程" class="header-anchor">#</a> 什么是线程？</h3> <ul><li>线程是CPU调度的最小单位，它是比进程更小的能独立运行的基本单位，由进程派生</li> <li>线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但它可与多个线程共享该进程的所拥有的资源</li></ul> <h3 id="什么是单线程"><a href="#什么是单线程" class="header-anchor">#</a> 什么是单线程？</h3> <p>单线程是指JS引擎执行JS时只分了一个线程给他执行，也就是执行JS时是单线程的。因为JS是单线程，所以如果没有事件循环，JS中将都是同步代码。</p> <h3 id="浏览器内核"><a href="#浏览器内核" class="header-anchor">#</a> 浏览器内核</h3> <ul><li><a href="https://blog.csdn.net/wu_xianqiang/article/details/105837869" target="_blank" rel="noopener noreferrer">详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <img src="/assets/img/browser_kernel.c579fe00.jpeg" alt="浏览器进程线程"></li> <li>V8引擎由许多子模块构成，其中这4个模块是最重要的
<ul><li>Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST)</li> <li>Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集3. TurboFan优化编译所需的信息，比如函数参数的类型；</li> <li>TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码；</li> <li>Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收；</li></ul></li></ul> <h3 id="调用栈-call-stack"><a href="#调用栈-call-stack" class="header-anchor">#</a> 调用栈（Call Stack）</h3> <p>调用栈它里面装的东西，是一个个待执行的函数。</p> <blockquote><p>Event Loop 会一直检查 Call Stack 中是否有函数需要执行，如果有，就从栈顶依次执行。同时，如果执行的过程中发现其他函数，继续入栈然后执行。</p></blockquote> <h3 id="任务分为两类"><a href="#任务分为两类" class="header-anchor">#</a> 任务分为两类</h3> <ul><li>同步任务：没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。
<ul><li>网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染</li></ul></li> <li>异步任务：被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务的回调函数加入宏任务队列中，最后加入调用栈执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。
<ul><li>而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务</li></ul></li></ul> <h3 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章</h3> <ul><li><a href="https://www.educative.io/edpresso/what-is-an-event-loop-in-javascript" target="_blank" rel="noopener noreferrer">setTimeout在event中如何执行的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://zhuanlan.zhihu.com/p/265349066" target="_blank" rel="noopener noreferrer">事件循环<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://javascript.info/event-loop#macrotasks-and-microtasks" target="_blank" rel="noopener noreferrer">讲的最好的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener noreferrer">什么是事件循环<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.ixigua.com/6806218718264164877?wid_try=1" target="_blank" rel="noopener noreferrer">视频讲解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.cnblogs.com/mfyngu/p/11747533.html" target="_blank" rel="noopener noreferrer">详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.jianshu.com/p/bfc3e319a96b" target="_blank" rel="noopener noreferrer">面试<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="执行顺序测试题"><a href="#执行顺序测试题" class="header-anchor">#</a> 执行顺序测试题</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//结果script start, script end, promise1, promise2, setTimeout</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="那怎么知道主线程执行栈为空呢"><a href="#那怎么知道主线程执行栈为空呢" class="header-anchor">#</a> 那怎么知道主线程执行栈为空呢？</h3> <p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去任务队列那里检查是否有等待被调用的函数。</p> <h3 id="加入async的执行顺序测试题"><a href="#加入async的执行顺序测试题" class="header-anchor">#</a> 加入async的执行顺序测试题</h3> <p><a href="https://www.cnblogs.com/shaozhu520/p/11341030.html" target="_blank" rel="noopener noreferrer">加入async看顺序<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>async执行返回值是一个promise，遇见promise会resolve它</li></ul> <h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="header-anchor">#</a> 宏任务与微任务</h2> <blockquote><p>除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。
宏任务是由宿主发起的，而微任务由JavaScript自身发起</p></blockquote> <ul><li>宏任务：由标准机制执行的任何JavaScript代码，宏任务代表一些离散和独立的工作，宏任务中的事件放在macroqueue中，由事件触发线程维护；</li> <li>微任务：当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。微任务的事件放在microqueue中，由js引擎线程维护；</li></ul> <h3 id="html规范定义"><a href="#html规范定义" class="header-anchor">#</a> html规范定义</h3> <p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener noreferrer">html规范<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide" target="_blank" rel="noopener noreferrer">MDN定义<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="在event-loop中-每一次tick任务的执行顺序"><a href="#在event-loop中-每一次tick任务的执行顺序" class="header-anchor">#</a> 在Event Loop中，每一次tick任务的执行顺序</h3> <blockquote><p>Event Loop中，每一次循环称为tick</p></blockquote> <ol><li>执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；</li> <li>检查是否存在微任务，有则会执行至微任务队列为空；</li> <li>如果宿主为浏览器，可能会渲染页面；</li> <li>开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）;</li></ol> <h3 id="有哪些是宏任务-macrotask-queue"><a href="#有哪些是宏任务-macrotask-queue" class="header-anchor">#</a> 有哪些是宏任务（macrotask queue）</h3> <ul><li>event callback</li> <li>整体代码script</li> <li>setTimeout/setInterval</li> <li>setImmediate,I/O(Node)</li> <li>UI rendering/UI事件（有相反意见的文章）</li> <li>requestAnimationFrame</li></ul> <h3 id="有哪些是微任务-microtask-queue"><a href="#有哪些是微任务-microtask-queue" class="header-anchor">#</a> 有哪些是微任务（microtask queue）</h3> <ul><li>原生Promise</li> <li>process.nextTick(Node)</li> <li>Object.observe(已废弃,Proxy 对象替代)</li> <li>MutationObserver（监控某个 DOM 节点）</li></ul> <h2 id="repaint-重绘-和-reflow-回流"><a href="#repaint-重绘-和-reflow-回流" class="header-anchor">#</a> repaint（重绘）和 reflow（回流）</h2> <ul><li>回流：比如我们增删DOM节点，修改一个元素的宽高，页面布局发生变化，DOM树结构发生变化，那么肯定要重新构建DOM树，而DOM树与渲染树是紧密相连的，DOM树构建完，渲染树也会随之对页面进行再次渲染，这个过程就叫回流。</li> <li>重绘：元素的某一部分属性发生改变，如字体颜色，背景颜色等改变，尺寸并未改变，这时发生的改变过程就是repaint。</li></ul> <h3 id="基本上能引起reflow的主要有几个原因"><a href="#基本上能引起reflow的主要有几个原因" class="header-anchor">#</a> 基本上能引起reflow的主要有几个原因</h3> <ul><li>网页初始化</li> <li>DOM的增删</li> <li>某些元素的尺寸改变，最好放在一个class中修改</li> <li>元素位置的变化，元素的左右margin，padding，所以使用定位或者transform性能更好</li> <li>获取元素的偏移量属性，scrollTop、scrollLeft、scrollWidth、offsetTop、offsetLeft、offsetWidth、offsetHeight，浏览器为了保证值的正确也会回流取得最新的值，所以如果你要多次操作，最取完做个缓存</li> <li>浏览器窗口尺寸改变，resize事件发生也会引起回流</li></ul> <h3 id="reflow影响性能-优化方法如下"><a href="#reflow影响性能-优化方法如下" class="header-anchor">#</a> reflow影响性能，优化方法如下</h3> <ul><li>修改样式不要逐条修改，建议定义CSS样式的class，然后直接修改元素的className</li> <li>不要将DOM节点的属性值放在循环中当成循环的变量</li> <li>为动画的 HTML 元素使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的</li> <li>把DOM离线后修改。如设置DOM的display：none，然后进行你需要的多次修改，然后再显示出来，或者clone一个节点到内存中，然后随意修改，修改完成后再与在线的交换【虚拟Dom，Diff算法就是这么优化的】</li> <li>不使用table布局，因为一个微小的改变就可能引起整个table的重新布局,当我们不为表格td添加固定宽度时，一列的td的宽度会以最宽td的宽作为渲染标准，假设前几行td在渲染时都渲染好了，结果下面某行的一个td特别宽，table为了统一宽，前几行的td会回流重新计算宽度，这是个很耗时的事情。</li> <li>由于display为none的元素在页面不需要渲染，渲染树构建不会包括这些节点；但visibility为hidden的元素会在渲染树中。因为display为none会脱离文档流，visibility为hidden虽然看不到，但类似与透明度为0，其实还在文档流中，还是有渲染的过程。</li></ul> <h2 id="说一下继承的几种方式及优缺点"><a href="#说一下继承的几种方式及优缺点" class="header-anchor">#</a> 说一下继承的几种方式及优缺点？</h2> <h3 id="原型链继承"><a href="#原型链继承" class="header-anchor">#</a> 原型链继承</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//父类</span>
<span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//子类</span>
<span class="token class-name">C</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">C</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yes'</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> cItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>缺点</p> <ol><li>新实例无法向父类构造函数传参。</li> <li>所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</li></ol> <h3 id="借用-盗用-构造函数继承"><a href="#借用-盗用-构造函数继承" class="header-anchor">#</a> 借用/盗用 构造函数继承</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//父类</span>
<span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;jer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//子类</span>
<span class="token keyword">let</span> cItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>缺点</p> <ol><li>只能继承父类构造函数的属性</li> <li>无法实现构造函数的复用（每次用每次都要重新调用）</li> <li>每个新实例都有父类构造函数的副本，臃肿</li></ol> <h3 id="组合继承-组合原型链继承和借用构造函数继承-常用"><a href="#组合继承-组合原型链继承和借用构造函数继承-常用" class="header-anchor">#</a> 组合继承（组合原型链继承和借用构造函数继承）（常用）</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//父类</span>
<span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//子类</span>
<span class="token class-name">C</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">C</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yes'</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> cItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token string">&quot;pig&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>特点：</li></ul> <ol><li>可以继承父类原型上的属性，可以传参，可复用。</li> <li>每个新实例引入的构造函数属性是私有的。</li></ol> <ul><li>缺点：</li></ul> <ol><li>调用了两次父类构造函数（耗内存）</li> <li>子类的构造函数会代替原型上的那个父类构造函数。</li></ol> <h3 id="寄生式继承"><a href="#寄生式继承" class="header-anchor">#</a> 寄生式继承</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
 <span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过调用函数创建一个新对象</span>
 clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 以某种方式增强这个对象</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span><span class="token punctuation">;</span> 
 <span class="token keyword">return</span> clone<span class="token punctuation">;</span> <span class="token comment">// 返回这个对象</span>
<span class="token punctuation">}</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">

### 寄生组合式继承（常用）
</span><span class="token template-punctuation string">`</span></span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>js
<span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">subType<span class="token punctuation">,</span> superType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">let</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建对象, 深拷贝</span>
 prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span> <span class="token comment">// 增强对象</span>
 
 subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span> <span class="token comment">// 赋值对象</span>
<span class="token punctuation">}</span> 

<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> 
 <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>SubType<span class="token punctuation">,</span> SuperType<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><div class="custom-block tip"><p class="title"></p><p>这里只调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性，因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此 instanceof 操作符和isPrototypeOf()方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。</p></div><h3 id="原型式继承-就是对象浅拷贝-object-create方法"><a href="#原型式继承-就是对象浅拷贝-object-create方法" class="header-anchor">#</a> 原型式继承，就是对象浅拷贝，Object.create方法</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
 <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span> 
 <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>构造函数中的共有属性无法做到数据共享，要做到数据共享，需要用到prototype</li></ul> <h2 id="javascript原型-原型链-有什么特点"><a href="#javascript原型-原型链-有什么特点" class="header-anchor">#</a> JavaScript原型，原型链 ? 有什么特点？</h2> <h3 id="原型prototype"><a href="#原型prototype" class="header-anchor">#</a> 原型prototype</h3> <blockquote><p>原型就是，创建一个函数时，会同时创建一个对象，函数的prototype会指向这个对象，然后这个对象默认有个属性叫constructor，指向这个函数。prototype指向的对象就是函数的原型对象，简称函数的原型
<img src="/assets/img/16.83b2db59.jpg" alt="prototype是什么"></p></blockquote> <ul><li>每个函数都有一个属性，叫prototype，它的值是一个对象，默认包含constructor属性，constructor属性是指向自己（即构造函数）。在Object函数的prototype中，还包含toString, hasOwnProperty等方法，所以创建的对象可以直接使用toString等方法</li> <li>每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性指向创建这个对象的函数的prototype。即：fn.<strong>proto</strong> === Fn.prototype（除了Object.create(null)没有），所以对象可以访问原型上的属性和方法
<img src="/assets/img/17.8c7e23a9.jpg" alt="prototype与__proto__"></li></ul> <h3 id="实例"><a href="#实例" class="header-anchor">#</a> 实例</h3> <blockquote><p>通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向它构造函数的原型，通过constructor指向构造函数。</p></blockquote> <h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，直至最顶级的原型对象Object.prototype，这就是<strong>原型链</strong>。</p> <h3 id="如何区分一个属性到底是基本的还是从原型中找到的呢"><a href="#如何区分一个属性到底是基本的还是从原型中找到的呢" class="header-anchor">#</a> 如何区分一个属性到底是基本的还是从原型中找到的呢</h3> <p>通过hasOwnProperty方法，特别是在for…in…循环(enumerable)中，一定要注意。</p> <h3 id="instanceof原理"><a href="#instanceof原理" class="header-anchor">#</a> instanceof原理</h3> <p>Instanceof的判断准则是：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。
<img src="/assets/img/18.95f04dc1.jpg" alt="instance的逻辑"></p> <h3 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h3> <p>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变当我们需要一个属性的时， Javascript 引擎会先看当前对象中是否有这个属性，如果没有的,就会查找__proto__这条线来找。</p> <h2 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h2> <blockquote><p>函数是特殊的可执行对象,函数中存在这一个内部属性[[Scope]]（我们不能使用，供js引擎使用）.
函数被创建时，这个内部属性就会包含函数被创建的作用域中对象的集合，这个集合呈链式链接，被称为函数的作用域链。
作用域链上的每一个对象被称为可变对象（Variable Obejct），每一个可变对象都以键值对形式存在。
我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p></blockquote> <ul><li>由两部分组成:
<ul><li>[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO</li> <li>AO: 自身活动对象
如此 [[scope]]包含[[scope]]，便自上而下形成一条 链式作用域。</li></ul></li></ul> <h3 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>它对应的[scope]</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 伪代码</span>
foo<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token constant">GO</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token operator">:</span> window <span class="token punctuation">,</span>
		window<span class="token operator">:</span> <span class="token operator">...</span> <span class="token punctuation">,</span>
		document<span class="token operator">:</span> <span class="token operator">...</span> <span class="token punctuation">,</span>
		<span class="token operator">...</span><span class="token operator">...</span>
		a<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token comment">// 预编译阶段还不知道a值是多少</span>
		<span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="scope-和执行上下文的区别"><a href="#scope-和执行上下文的区别" class="header-anchor">#</a> [[Scope]]和执行上下文的区别</h3> <ul><li>共同：都保存了函数作用域链</li> <li>[[Scope]]属性是函数创建时产生的，会一直存在</li> <li>而执行上下文在函数执行时产生，函数执行结束便会销毁</li></ul> <h3 id="参考文章-2"><a href="#参考文章-2" class="header-anchor">#</a> 参考文章</h3> <p><a href="https://blog.csdn.net/q1056843325/article/details/53086893" target="_blank" rel="noopener noreferrer">CSDN详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="执行上下文-ec-执行环境"><a href="#执行上下文-ec-执行环境" class="header-anchor">#</a> 执行上下文(EC)/执行环境</h2> <blockquote><p>执行上下文可以简单理解为一个对象【内部对象】</p></blockquote> <ul><li>它包含三个部分:
<ul><li>变量对象(VO)</li> <li>作用域链(词法作用域)</li> <li>this指向</li></ul></li> <li>它的类型:
<ul><li>全局执行上下文</li> <li>函数执行上下文</li> <li>eval执行上下文</li></ul></li> <li>代码执行过程:
<ul><li>创建 全局上下文 (global EC)</li> <li>全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层</li> <li>函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起</li> <li>函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行</li></ul></li></ul> <h3 id="特点-2"><a href="#特点-2" class="header-anchor">#</a> 特点</h3> <ul><li>它定义了一个函数执行时的环境</li> <li>函数每次执行时的执行环境独一无二</li> <li>多次调用函数就多次创建执行环境</li> <li>并且函数执行完毕后，执行环境就会被销毁</li> <li>执行环境有自己的作用域链，用于解析标识符</li></ul> <h3 id="变量对象"><a href="#变量对象" class="header-anchor">#</a> 变量对象</h3> <p>变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 变量和函数声明(不包含函数表达式)。</p> <blockquote><p>活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。</p></blockquote> <h3 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h3> <p>执行上下文中还包含作用域链。理解作用域链之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 变量和函数的作用范围。可分为 块级作用域 和 函数作用域。（js引擎根据名称查找变量的一套规则）</p> <ul><li>特性:
<ul><li>声明提前: 一个声明在函数体内都是可见的, 函数优先于变量</li> <li>非匿名自执行函数，函数变量为 只读 状态，无法修改</li></ul></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果去掉foo，打印的就是10</span>
    foo <span class="token operator">=</span> <span class="token number">10</span>  <span class="token comment">// 由于foo在函数中只为可读，因此赋值无效</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 

<span class="token comment">// 结果打印：  ƒ foo() { foo = 10 ; console.log(foo) }</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <blockquote><p>闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。</p></blockquote> <h3 id="特点-3"><a href="#特点-3" class="header-anchor">#</a> 特点：</h3> <ul><li>函数内再嵌套函数</li> <li>内部函数可以引用外层的参数和变量</li> <li>参数和变量不会被垃圾回收机制回收</li> <li>优点：能够实现封装和缓存等</li> <li>缺点：消耗内存、使用不当会内存溢出，</li> <li>解决方法：在退出函数之前，将不使用的局部变量全部删除</li></ul> <h2 id="this的取值-分五种情况"><a href="#this的取值-分五种情况" class="header-anchor">#</a> this的取值, 分五种情况</h2> <ol><li>构造函数，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象</li> <li>函数作为对象的一个属性，如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	name<span class="token operator">:</span> <span class="token string">'aa'</span><span class="token punctuation">,</span>
	<span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="3"><li>函数用call或者apply调用, 当一个函数被call和apply调用时，this的值就取传入的对象的值。</li> <li>全局 &amp; 调用普通函数, 在全局环境下，this永远是window
<img src="/assets/img/19.5958b7d3.jpg" alt="特例"></li> <li>监听事件回调函数中的this, 指向触发这个事件的对象，特殊的是， IE 中的 attachEvent 中的this 总是指向全局对象 Window</li></ol> <h2 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="header-anchor">#</a> new操作符具体干了什么呢?</h2> <ul><li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</li> <li>属性和方法被加入到 this 引用的对象中</li> <li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li></ul> <h2 id="commonjs-规范"><a href="#commonjs-规范" class="header-anchor">#</a> commonjs 规范</h2> <ul><li>exports = module.exports</li> <li>exports</li> <li>module</li> <li>require</li></ul> <h2 id="export和export-default的区别"><a href="#export和export-default的区别" class="header-anchor">#</a> export和export default的区别？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span>  xxx
<span class="token keyword">import</span> xxx <span class="token keyword">from</span> <span class="token string">'./'</span>

<span class="token keyword">export</span> xxx
<span class="token keyword">import</span> <span class="token punctuation">{</span>xxx<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="js有哪些方法定义对象"><a href="#js有哪些方法定义对象" class="header-anchor">#</a> JS有哪些方法定义对象</h2> <ul><li>对象字面量： var obj = {};</li> <li>构造函数： var obj = new Object();</li> <li>Object.create(): var obj = Object.create(Object.prototype);</li></ul> <h2 id="如何通过js判断一个数组"><a href="#如何通过js判断一个数组" class="header-anchor">#</a> 如何通过JS判断一个数组</h2> <ol><li>instanceof  (arr instanceof Array)   ifrmae不行（iframe.createElement（'script'）instanceof Element）</li> <li>isArray (Array.isArray([]) //true)</li> <li>constructor (arr.constructor == Array; //true)</li> <li>Object.prototype  (Object.prototype.toString.call([]) == '[object Array]')</li> <li>Array.prototype.isPrototypeOf(obj)</li></ol> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <ul><li>jsonp</li> <li>cors</li></ul> <blockquote><p>参考掘金收藏文章，完善</p></blockquote> <h2 id="参考文章-3"><a href="#参考文章-3" class="header-anchor">#</a> 参考文章</h2> <p><a href="https://juejin.cn/post/6844903776512393224#heading-20" target="_blank" rel="noopener noreferrer">中高级<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://juejin.cn/post/6940945178899251230" target="_blank" rel="noopener noreferrer">2021<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/other/interview-js.html#讲讲js的数据类型" class="sidebar-link reco-side-讲讲js的数据类型" data-v-70334359>讲讲JS的数据类型？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#_7-种原始类型【primitive】" class="sidebar-link reco-side-_7-种原始类型【primitive】" data-v-70334359>7 种原始类型【primitive】</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#_2-种结构类型" class="sidebar-link reco-side-_2-种结构类型" data-v-70334359>2 种结构类型</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#symbol类型" class="sidebar-link reco-side-symbol类型" data-v-70334359>Symbol类型</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#symbol函数可以接受一个字符串作为参数" class="sidebar-link reco-side-symbol函数可以接受一个字符串作为参数" data-v-70334359>Symbol函数可以接受一个字符串作为参数</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#如果-symbol-的参数是一个对象" class="sidebar-link reco-side-如果-symbol-的参数是一个对象" data-v-70334359>如果 Symbol 的参数是一个对象</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#symbol-类型转化" class="sidebar-link reco-side-symbol-类型转化" data-v-70334359>Symbol 类型转化</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#symbol作为属性名被遍历" class="sidebar-link reco-side-symbol作为属性名被遍历" data-v-70334359>Symbol作为属性名被遍历</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#异步编程实现方式" class="sidebar-link reco-side-异步编程实现方式" data-v-70334359>异步编程实现方式</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#找到a节点的父节点下的所有子节点" class="sidebar-link reco-side-找到a节点的父节点下的所有子节点" data-v-70334359>找到A节点的父节点下的所有子节点</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#encodeuri和encodeuricomponent的比较" class="sidebar-link reco-side-encodeuri和encodeuricomponent的比较" data-v-70334359>encodeURI和encodeURIComponent的比较</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#事件循环【event-loop】" class="sidebar-link reco-side-事件循环【event-loop】" data-v-70334359>事件循环【Event Loop】</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#event-loop是什么" class="sidebar-link reco-side-event-loop是什么" data-v-70334359>Event Loop是什么？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#event-loop执行流程" class="sidebar-link reco-side-event-loop执行流程" data-v-70334359>Event Loop执行流程</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#什么是进程" class="sidebar-link reco-side-什么是进程" data-v-70334359>什么是进程？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#什么是线程" class="sidebar-link reco-side-什么是线程" data-v-70334359>什么是线程？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#什么是单线程" class="sidebar-link reco-side-什么是单线程" data-v-70334359>什么是单线程？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#浏览器内核" class="sidebar-link reco-side-浏览器内核" data-v-70334359>浏览器内核</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#调用栈-call-stack" class="sidebar-link reco-side-调用栈-call-stack" data-v-70334359>调用栈（Call Stack）</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#任务分为两类" class="sidebar-link reco-side-任务分为两类" data-v-70334359>任务分为两类</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#参考文章" class="sidebar-link reco-side-参考文章" data-v-70334359>参考文章</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#执行顺序测试题" class="sidebar-link reco-side-执行顺序测试题" data-v-70334359>执行顺序测试题</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#那怎么知道主线程执行栈为空呢" class="sidebar-link reco-side-那怎么知道主线程执行栈为空呢" data-v-70334359>那怎么知道主线程执行栈为空呢？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#加入async的执行顺序测试题" class="sidebar-link reco-side-加入async的执行顺序测试题" data-v-70334359>加入async的执行顺序测试题</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#宏任务与微任务" class="sidebar-link reco-side-宏任务与微任务" data-v-70334359>宏任务与微任务</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#html规范定义" class="sidebar-link reco-side-html规范定义" data-v-70334359>html规范定义</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#在event-loop中-每一次tick任务的执行顺序" class="sidebar-link reco-side-在event-loop中-每一次tick任务的执行顺序" data-v-70334359>在Event Loop中，每一次tick任务的执行顺序</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#有哪些是宏任务-macrotask-queue" class="sidebar-link reco-side-有哪些是宏任务-macrotask-queue" data-v-70334359>有哪些是宏任务（macrotask queue）</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#有哪些是微任务-microtask-queue" class="sidebar-link reco-side-有哪些是微任务-microtask-queue" data-v-70334359>有哪些是微任务（microtask queue）</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#repaint-重绘-和-reflow-回流" class="sidebar-link reco-side-repaint-重绘-和-reflow-回流" data-v-70334359>repaint（重绘）和 reflow（回流）</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#基本上能引起reflow的主要有几个原因" class="sidebar-link reco-side-基本上能引起reflow的主要有几个原因" data-v-70334359>基本上能引起reflow的主要有几个原因</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#reflow影响性能-优化方法如下" class="sidebar-link reco-side-reflow影响性能-优化方法如下" data-v-70334359>reflow影响性能，优化方法如下</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#说一下继承的几种方式及优缺点" class="sidebar-link reco-side-说一下继承的几种方式及优缺点" data-v-70334359>说一下继承的几种方式及优缺点？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#原型链继承" class="sidebar-link reco-side-原型链继承" data-v-70334359>原型链继承</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#借用-盗用-构造函数继承" class="sidebar-link reco-side-借用-盗用-构造函数继承" data-v-70334359>借用/盗用 构造函数继承</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#组合继承-组合原型链继承和借用构造函数继承-常用" class="sidebar-link reco-side-组合继承-组合原型链继承和借用构造函数继承-常用" data-v-70334359>组合继承（组合原型链继承和借用构造函数继承）（常用）</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#寄生式继承" class="sidebar-link reco-side-寄生式继承" data-v-70334359>寄生式继承</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#原型式继承-就是对象浅拷贝-object-create方法" class="sidebar-link reco-side-原型式继承-就是对象浅拷贝-object-create方法" data-v-70334359>原型式继承，就是对象浅拷贝，Object.create方法</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#javascript原型-原型链-有什么特点" class="sidebar-link reco-side-javascript原型-原型链-有什么特点" data-v-70334359>JavaScript原型，原型链 ? 有什么特点？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#原型prototype" class="sidebar-link reco-side-原型prototype" data-v-70334359>原型prototype</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#实例" class="sidebar-link reco-side-实例" data-v-70334359>实例</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#原型链" class="sidebar-link reco-side-原型链" data-v-70334359>原型链</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#如何区分一个属性到底是基本的还是从原型中找到的呢" class="sidebar-link reco-side-如何区分一个属性到底是基本的还是从原型中找到的呢" data-v-70334359>如何区分一个属性到底是基本的还是从原型中找到的呢</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#instanceof原理" class="sidebar-link reco-side-instanceof原理" data-v-70334359>instanceof原理</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#特点" class="sidebar-link reco-side-特点" data-v-70334359>特点</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#作用域链" class="sidebar-link reco-side-作用域链" data-v-70334359>作用域链</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#例子" class="sidebar-link reco-side-例子" data-v-70334359>例子</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#scope-和执行上下文的区别" class="sidebar-link reco-side-scope-和执行上下文的区别" data-v-70334359>[[Scope]]和执行上下文的区别</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#参考文章-2" class="sidebar-link reco-side-参考文章-2" data-v-70334359>参考文章</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#执行上下文-ec-执行环境" class="sidebar-link reco-side-执行上下文-ec-执行环境" data-v-70334359>执行上下文(EC)/执行环境</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#特点-2" class="sidebar-link reco-side-特点-2" data-v-70334359>特点</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#变量对象" class="sidebar-link reco-side-变量对象" data-v-70334359>变量对象</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#作用域" class="sidebar-link reco-side-作用域" data-v-70334359>作用域</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#闭包" class="sidebar-link reco-side-闭包" data-v-70334359>闭包</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#特点-3" class="sidebar-link reco-side-特点-3" data-v-70334359>特点：</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#this的取值-分五种情况" class="sidebar-link reco-side-this的取值-分五种情况" data-v-70334359>this的取值, 分五种情况</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#new操作符具体干了什么呢" class="sidebar-link reco-side-new操作符具体干了什么呢" data-v-70334359>new操作符具体干了什么呢?</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#commonjs-规范" class="sidebar-link reco-side-commonjs-规范" data-v-70334359>commonjs 规范</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#export和export-default的区别" class="sidebar-link reco-side-export和export-default的区别" data-v-70334359>export和export default的区别？</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#js有哪些方法定义对象" class="sidebar-link reco-side-js有哪些方法定义对象" data-v-70334359>JS有哪些方法定义对象</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#如何通过js判断一个数组" class="sidebar-link reco-side-如何通过js判断一个数组" data-v-70334359>如何通过JS判断一个数组</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#跨域" class="sidebar-link reco-side-跨域" data-v-70334359>跨域</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#参考文章-3" class="sidebar-link reco-side-参考文章-3" data-v-70334359>参考文章</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.3d95d36a.js" defer></script><script src="/assets/js/3.d4f79d98.js" defer></script><script src="/assets/js/1.4877e3be.js" defer></script><script src="/assets/js/8.4fbb2fd7.js" defer></script>
  </body>
</html>
