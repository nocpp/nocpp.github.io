<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS相关 | 干蛋杂货铺</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="记录学到的知识，活到老，学到老">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.fd6f0cf4.css" as="style"><link rel="preload" href="/assets/js/app.de4e8d83.js" as="script"><link rel="preload" href="/assets/js/3.c95393d0.js" as="script"><link rel="preload" href="/assets/js/1.4877e3be.js" as="script"><link rel="preload" href="/assets/js/49.11fdfc33.js" as="script"><link rel="prefetch" href="/assets/js/10.df5ffe8f.js"><link rel="prefetch" href="/assets/js/11.88b59537.js"><link rel="prefetch" href="/assets/js/12.542fb0d2.js"><link rel="prefetch" href="/assets/js/13.fa443286.js"><link rel="prefetch" href="/assets/js/14.7f3a3426.js"><link rel="prefetch" href="/assets/js/15.43048124.js"><link rel="prefetch" href="/assets/js/16.0ad83175.js"><link rel="prefetch" href="/assets/js/17.3c5b09a1.js"><link rel="prefetch" href="/assets/js/18.1edd2aa2.js"><link rel="prefetch" href="/assets/js/19.bda09315.js"><link rel="prefetch" href="/assets/js/20.04052941.js"><link rel="prefetch" href="/assets/js/21.f493a8cc.js"><link rel="prefetch" href="/assets/js/22.b6c9c690.js"><link rel="prefetch" href="/assets/js/23.506c8786.js"><link rel="prefetch" href="/assets/js/24.cb1d385d.js"><link rel="prefetch" href="/assets/js/25.7a33680c.js"><link rel="prefetch" href="/assets/js/26.27fe6bd7.js"><link rel="prefetch" href="/assets/js/27.e8ad1957.js"><link rel="prefetch" href="/assets/js/28.258ba681.js"><link rel="prefetch" href="/assets/js/29.68554a00.js"><link rel="prefetch" href="/assets/js/30.f9691048.js"><link rel="prefetch" href="/assets/js/31.9fe5f7bf.js"><link rel="prefetch" href="/assets/js/32.bf0cf9d1.js"><link rel="prefetch" href="/assets/js/33.f756cd12.js"><link rel="prefetch" href="/assets/js/34.0815eea4.js"><link rel="prefetch" href="/assets/js/35.a8a68df8.js"><link rel="prefetch" href="/assets/js/36.a40e0fff.js"><link rel="prefetch" href="/assets/js/37.da75e319.js"><link rel="prefetch" href="/assets/js/38.b13e2e06.js"><link rel="prefetch" href="/assets/js/39.a4a1c555.js"><link rel="prefetch" href="/assets/js/4.4d24b8a2.js"><link rel="prefetch" href="/assets/js/40.0c8e55b7.js"><link rel="prefetch" href="/assets/js/41.25a18468.js"><link rel="prefetch" href="/assets/js/42.c56a7592.js"><link rel="prefetch" href="/assets/js/43.5ef5ab38.js"><link rel="prefetch" href="/assets/js/44.dc23549e.js"><link rel="prefetch" href="/assets/js/45.79010fd0.js"><link rel="prefetch" href="/assets/js/46.ea8a9b59.js"><link rel="prefetch" href="/assets/js/47.cf4d8b7e.js"><link rel="prefetch" href="/assets/js/48.2db6aaa7.js"><link rel="prefetch" href="/assets/js/5.9431b70e.js"><link rel="prefetch" href="/assets/js/50.78e96985.js"><link rel="prefetch" href="/assets/js/51.83009caf.js"><link rel="prefetch" href="/assets/js/52.b66ab4a3.js"><link rel="prefetch" href="/assets/js/53.15eb8d14.js"><link rel="prefetch" href="/assets/js/54.cc310751.js"><link rel="prefetch" href="/assets/js/55.c41c3508.js"><link rel="prefetch" href="/assets/js/56.d12acb33.js"><link rel="prefetch" href="/assets/js/57.f2e9a57c.js"><link rel="prefetch" href="/assets/js/58.05b1ea2c.js"><link rel="prefetch" href="/assets/js/59.d2d315a4.js"><link rel="prefetch" href="/assets/js/6.0578949e.js"><link rel="prefetch" href="/assets/js/60.04659ccc.js"><link rel="prefetch" href="/assets/js/61.8e6df5c1.js"><link rel="prefetch" href="/assets/js/62.d3150102.js"><link rel="prefetch" href="/assets/js/63.4c25d7c0.js"><link rel="prefetch" href="/assets/js/64.4361e750.js"><link rel="prefetch" href="/assets/js/65.03e8a1ea.js"><link rel="prefetch" href="/assets/js/66.1b62a440.js"><link rel="prefetch" href="/assets/js/67.098b485a.js"><link rel="prefetch" href="/assets/js/7.9b418213.js"><link rel="prefetch" href="/assets/js/8.f7bfa404.js"><link rel="prefetch" href="/assets/js/9.d2b59959.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fd6f0cf4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>干蛋杂货铺</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>记录学到的知识，活到老，学到老</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><!---->
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">干蛋杂货铺</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-date"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/数据结构/" class="nav-link"><i class="undefined"></i>
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/categories/javascript/" class="nav-link"><i class="undefined"></i>
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/categories/设计模式/" class="nav-link"><i class="undefined"></i>
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/categories/实战/" class="nav-link"><i class="undefined"></i>
  实战
</a></li><li class="dropdown-item"><!----> <a href="/categories/杂项/" class="nav-link"><i class="undefined"></i>
  杂项
</a></li><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/categories/vue/" class="nav-link"><i class="undefined"></i>
  vue
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="./avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <!----> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>54</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>51</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-date"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/数据结构/" class="nav-link"><i class="undefined"></i>
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/categories/javascript/" class="nav-link"><i class="undefined"></i>
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/categories/设计模式/" class="nav-link"><i class="undefined"></i>
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/categories/实战/" class="nav-link"><i class="undefined"></i>
  实战
</a></li><li class="dropdown-item"><!----> <a href="/categories/杂项/" class="nav-link"><i class="undefined"></i>
  杂项
</a></li><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/categories/vue/" class="nav-link"><i class="undefined"></i>
  vue
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>JS相关</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><!---->
            
          <!---->
          2021
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">JS相关</h1> <div data-v-1ff7123e><!----> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>12/20/2021</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>JS</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="讲讲js的数据类型"><a href="#讲讲js的数据类型" class="header-anchor">#</a> 讲讲JS的数据类型？</h2> <p>最新的 ECMAScript 标准定义了 9种数据类型:</p> <h3 id="_7-种原始类型"><a href="#_7-种原始类型" class="header-anchor">#</a> 7 种原始类型</h3> <ul><li>Boolean</li> <li>Undefined</li> <li>Null</li> <li>Number</li> <li>BigInt  11n,22n这就是这个类型的</li> <li>String</li> <li>Symbol  let s = Symbol()</li></ul> <h3 id="_2-种结构类型"><a href="#_2-种结构类型" class="header-anchor">#</a> 2 种结构类型</h3> <ul><li>Object</li> <li>Function</li></ul> <h2 id="symbol类型"><a href="#symbol类型" class="header-anchor">#</a> Symbol类型</h2> <p>由于ES5中对象属性名都是字符串，有可能造成命名重复，所以ES6提出的Symbol类型解决这个问题。Symbol 值通过Symbol函数生成。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token comment">//第一种写法</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">'Hello!'</span><span class="token comment">//第二种写法</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token string">'Hello!'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第三种写法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1000</span>
window<span class="token punctuation">.</span>s <span class="token comment">//这样不行，不能用点运算符。因为点运算符后面总是字符串</span>

<span class="token keyword">typeof</span> s
<span class="token comment">// &quot;symbol&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p></blockquote> <div class="custom-block danger"><p class="title"></p><p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p></div><h3 id="symbol函数可以接受一个字符串作为参数"><a href="#symbol函数可以接受一个字符串作为参数" class="header-anchor">#</a> Symbol函数可以接受一个字符串作为参数</h3> <p>表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p> <div class="custom-block danger"><p class="title"></p><p>注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

s1 <span class="token comment">// Symbol(foo)</span>
s2 <span class="token comment">// Symbol(bar)</span>

s1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;Symbol(foo)&quot;</span>
s2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;Symbol(bar)&quot;</span>

<span class="token comment">//ES2019 提供description可以读取描述</span>
s1<span class="token punctuation">.</span>description <span class="token comment">// &quot;foo&quot;</span>

<span class="token comment">// 有参数的情况</span>
<span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

s1 <span class="token operator">===</span> s2 <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="如果-symbol-的参数是一个对象"><a href="#如果-symbol-的参数是一个对象" class="header-anchor">#</a> 如果 Symbol 的参数是一个对象</h3> <p>就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
sym <span class="token comment">// Symbol(abc)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="symbol-类型转化"><a href="#symbol-类型转化" class="header-anchor">#</a> Symbol 类型转化</h3> <p>Symbol 值不能与其他类型的值进行运算，会报错，但是可以转为字符串和布尔值，不能转为数值</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s <span class="token operator">+</span> <span class="token string">'abc'</span> <span class="token comment">//会报错</span>
s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//可以</span>
<span class="token function">String</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">//可以</span>
<span class="token function">Boolean</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">//可以</span>
<span class="token operator">!</span>s <span class="token comment">//可以</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="symbol作为属性名被遍历"><a href="#symbol作为属性名被遍历" class="header-anchor">#</a> Symbol作为属性名被遍历</h3> <p>遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。</p> <p>但是，它也不是私有属性，有一个Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

obj<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Hello'</span><span class="token punctuation">;</span>
obj<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'World'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> objectSymbols <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

objectSymbols
<span class="token comment">// [Symbol(a), Symbol(b)]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="异步编程实现方式"><a href="#异步编程实现方式" class="header-anchor">#</a> 异步编程实现方式</h2> <ul><li>回调函数
<ul><li>优点：简单、容易理解</li> <li>缺点：不利于维护，代码耦合高</li></ul></li> <li>事件监听(采用时间驱动模式，取决于某个事件是否发生)
<ul><li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li> <li>缺点：事件驱动型，流程不够清晰</li></ul></li> <li>发布/订阅(观察者模式)
<ul><li>类似于事件监听，但是可以通过‘消息中心‘，了解现在有多少发布者，多少订阅者</li></ul></li> <li>Promise对象
<ul><li>优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；</li> <li>缺点：编写和理解，相对比较难</li></ul></li> <li>Generator函数
<ul><li>优点：函数体内外的数据交换、错误处理机制</li> <li>缺点：流程管理不方便</li></ul></li> <li>async函数
<ul><li>优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。</li> <li>缺点：错误处理机制</li></ul></li></ul> <h2 id="找到a节点的父节点下的所有子节点"><a href="#找到a节点的父节点下的所有子节点" class="header-anchor">#</a> 找到A节点的父节点下的所有子节点</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> b<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span>children<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="encodeuri和encodeuricomponent的比较"><a href="#encodeuri和encodeuricomponent的比较" class="header-anchor">#</a> encodeURI和encodeURIComponent的比较</h2> <ul><li>相同点：都可以对url进行一个编码；</li> <li>encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、下划线、问号和井字号，适用于url跳转时；</li> <li>encodeURIComponent()则会对它发现的任何非标准字符进行编码，适用于有参数要传递时。</li></ul> <blockquote><p>注意：当url作为参数传递时如果没有用encodeURIComponent进行编码，往往会造成传递时url中的特殊字符丢失。</p></blockquote> <h2 id="事件循环【event-loop】"><a href="#事件循环【event-loop】" class="header-anchor">#</a> 事件循环【Event Loop】</h2> <h3 id="event-loop是什么"><a href="#event-loop是什么" class="header-anchor">#</a> Event Loop是什么？</h3> <p>事件循环是JS的执行机制。</p> <h3 id="为什么有event-loop"><a href="#为什么有event-loop" class="header-anchor">#</a> 为什么有Event Loop？</h3> <p>因为JS是单线程的，如果没有Event Loop，在执行费时间的任务时，页面会卡顿，不会继续往下执行。</p> <h3 id="任务分为两类"><a href="#任务分为两类" class="header-anchor">#</a> 任务分为两类</h3> <ul><li>同步任务：按时间顺序执行，执行完上一个才能执行下一个，是否进入异步队列来判断【React中setState目前就是同步的】。</li> <li>异步任务：不按时间顺序执行，执行到异步任务时，进入Event Table并注册函数，然后往下执行，异步任务完成后，推入事件队列中。主线程执行完后，执行事件队列中函数（eg: setTimeout,setInterval,ajax,IO读写）</li></ul> <h3 id="执行顺序测试题"><a href="#执行顺序测试题" class="header-anchor">#</a> 执行顺序测试题</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//结果script start, script end, promise1, promise2, setTimeout</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="执行步骤"><a href="#执行步骤" class="header-anchor">#</a> 执行步骤：</h3> <ol><li>同步和异步任务分别进入不同的执行&quot;场所&quot;，同步的进入主线程，异步的进入Event Table并注册函数</li> <li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li> <li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li> <li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ol> <h3 id="代码解析"><a href="#代码解析" class="header-anchor">#</a> 代码解析：</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 1. ajax进入Event Table，注册回调函数success。
 * 2. 执行console.log('代码执行结束')。
 * 3. ajax事件完成，回调函数success进入Event Queue。
 * 4. 主线程从Event Queue读取回调函数success并执行。
 */</span>
<span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    url<span class="token operator">:</span> <span class="token string">'www.javascript.com'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span>data<span class="token punctuation">,</span>
    <span class="token function-variable function">success</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'发送成功!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'代码执行结束'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="那怎么知道主线程执行栈为空呢"><a href="#那怎么知道主线程执行栈为空呢" class="header-anchor">#</a> 那怎么知道主线程执行栈为空呢？</h3> <p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p> <h3 id="加入async的执行顺序测试题"><a href="#加入async的执行顺序测试题" class="header-anchor">#</a> 加入async的执行顺序测试题</h3> <p><a href="https://www.cnblogs.com/shaozhu520/p/11341030.html" target="_blank" rel="noopener noreferrer">加入async看顺序<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>async执行返回值是一个promise，遇见promise会resolve它</li></ul> <h2 id="宏任务与微任务【异步任务】"><a href="#宏任务与微任务【异步任务】" class="header-anchor">#</a> 宏任务与微任务【异步任务】</h2> <ul><li>宏任务：当前调用栈中执行的任务称为宏任务。宏任务中的事件放在callback queue中，由事件触发线程维护；</li> <li>微任务：当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。微任务的事件放在微任务队列中，由js引擎线程维护。</li></ul> <h3 id="在event-loop中-每一次tick任务的执行顺序"><a href="#在event-loop中-每一次tick任务的执行顺序" class="header-anchor">#</a> 在Event Loop中，每一次tick任务的执行顺序</h3> <blockquote><p>Event Loop中，每一次循环称为tick</p></blockquote> <ol><li>执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；</li> <li>检查是否存在微任务，有则会执行至微任务队列为空；</li> <li>如果宿主为浏览器，可能会渲染页面；</li> <li>开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）;</li></ol> <h3 id="有哪些是宏任务-macrotask-queue"><a href="#有哪些是宏任务-macrotask-queue" class="header-anchor">#</a> 有哪些是宏任务（macrotask queue）</h3> <ul><li>整体代码script</li> <li>mousemove</li> <li>setTimeout</li> <li>setInterval</li> <li>setImmediate</li></ul> <h3 id="有哪些是微任务-microtask-queue"><a href="#有哪些是微任务-microtask-queue" class="header-anchor">#</a> 有哪些是微任务（microtask queue）</h3> <ul><li>原生Promise(有些实现的promise将then方法放到了宏任务中)</li> <li>process.nextTick</li> <li>Object.observe(已废弃)</li> <li>MutationObserver</li></ul> <h2 id="repaint-重绘-和-reflow-回流"><a href="#repaint-重绘-和-reflow-回流" class="header-anchor">#</a> repaint（重绘）和 reflow（回流）</h2> <ul><li>重绘：元素的某一部分属性发生改变，如字体颜色，背景颜色等改变，尺寸并未改变，这时发生的改变过程就是repaint。</li> <li>回流：因为浏览器渲染是一个由上而下的过程，当发现某部分的变化影响了布局时，就需要倒回去重新渲染，这个过程就称之为reflow。reflow几乎是没法避免的，现在一些常用的效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。</li></ul> <h3 id="基本上能引起reflow的主要有几个原因"><a href="#基本上能引起reflow的主要有几个原因" class="header-anchor">#</a> 基本上能引起reflow的主要有几个原因</h3> <ul><li>网页初始化</li> <li>JS操作DOM树的时候，增加删除元素等</li> <li>某些元素的尺寸改变</li> <li>CSS属性的改变</li></ul> <h3 id="reflow影响性能-优化方法如下"><a href="#reflow影响性能-优化方法如下" class="header-anchor">#</a> reflow影响性能，优化方法如下</h3> <ul><li>修改样式不要逐条修改，建议定义CSS样式的class，然后直接修改元素的className</li> <li>不要将DOM节点的属性值放在循环中当成循环的变量</li> <li>为动画的 HTML 元素使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的</li> <li>把DOM离线后修改。如设置DOM的display：none，然后进行你需要的多次修改，然后再显示出来，或者clone一个节点到内存中，然后随意修改，修改完成后再与在线的交换【虚拟Dom，Diff算法就是这么优化的】</li> <li>不使用table布局，因为一个微小的改变就可能引起整个table的重新布局</li></ul> <h2 id="说一下继承的几种方式及优缺点"><a href="#说一下继承的几种方式及优缺点" class="header-anchor">#</a> 说一下继承的几种方式及优缺点？</h2> <h3 id="原型链继承"><a href="#原型链继承" class="header-anchor">#</a> 原型链继承</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//父类</span>
<span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//子类</span>
<span class="token class-name">C</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">C</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yes'</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> cItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>缺点</p> <ol><li>新实例无法向父类构造函数传参。</li> <li>所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</li></ol> <h3 id="借用-盗用-构造函数继承"><a href="#借用-盗用-构造函数继承" class="header-anchor">#</a> 借用/盗用 构造函数继承</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//父类</span>
<span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;jer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//子类</span>
<span class="token keyword">let</span> cItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>缺点</p> <ol><li>只能继承父类构造函数的属性</li> <li>无法实现构造函数的复用（每次用每次都要重新调用）</li> <li>每个新实例都有父类构造函数的副本，臃肿</li></ol> <h3 id="组合继承-组合原型链继承和借用构造函数继承-常用"><a href="#组合继承-组合原型链继承和借用构造函数继承-常用" class="header-anchor">#</a> 组合继承（组合原型链继承和借用构造函数继承）（常用）</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//父类</span>
<span class="token keyword">function</span> <span class="token constant">C</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//子类</span>
<span class="token class-name">C</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">C</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yes'</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> cItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token string">&quot;pig&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>特点：</p> <ol><li>可以继承父类原型上的属性，可以传参，可复用。</li> <li>每个新实例引入的构造函数属性是私有的。
缺点：</li> <li>调用了两次父类构造函数（耗内存）</li> <li>子类的构造函数会代替原型上的那个父类构造函数。</li></ol> <h3 id="寄生式继承"><a href="#寄生式继承" class="header-anchor">#</a> 寄生式继承</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
 <span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过调用函数创建一个新对象</span>
 clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 以某种方式增强这个对象</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span><span class="token punctuation">;</span> 
 <span class="token keyword">return</span> clone<span class="token punctuation">;</span> <span class="token comment">// 返回这个对象</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="寄生组合式继承-常用"><a href="#寄生组合式继承-常用" class="header-anchor">#</a> 寄生组合式继承（常用）</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">subType<span class="token punctuation">,</span> superType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">let</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建对象, 深拷贝</span>
 prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span> <span class="token comment">// 增强对象</span>
 
 subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span> <span class="token comment">// 赋值对象</span>
<span class="token punctuation">}</span> 


<span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> 
 <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>SubType<span class="token punctuation">,</span> SuperType<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><div class="custom-block tip"><p class="title"></p><p>这里只调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性，因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此 instanceof 操作符和isPrototypeOf()方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。</p></div><h3 id="原型式继承-就是对象浅拷贝-object-create方法"><a href="#原型式继承-就是对象浅拷贝-object-create方法" class="header-anchor">#</a> 原型式继承，就是对象浅拷贝，Object.create方法</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
 <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span> 
 <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>构造函数中的共有属性无法做到数据共享，要做到数据共享，需要用到prototype</li></ul> <h2 id="javascript原型-原型链-有什么特点"><a href="#javascript原型-原型链-有什么特点" class="header-anchor">#</a> JavaScript原型，原型链 ? 有什么特点？</h2> <h3 id="原型prototype"><a href="#原型prototype" class="header-anchor">#</a> 原型prototype</h3> <p><img src="%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95_files/16.jpg" alt="prototype是什么"></p> <ul><li>每个函数都有一个属性，叫prototype，它的值是一个对象，默认包含constructor属性，constructor属性是指向自己（即构造函数）。在Object函数的prototype中，还包含toString, hasOwnProperty等方法，所以创建的对象可以直接使用toString等方法</li> <li>每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性指向创建这个对象的函数的prototype。即：fn.<strong>proto</strong> === Fn.prototype（除了Object.create(null)没有），所以对象可以访问原型上的属性和方法
<img src="%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95_files/17.jpg" alt="prototype与__proto__"></li></ul> <h3 id="实例"><a href="#实例" class="header-anchor">#</a> 实例</h3> <blockquote><p>通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向它构造函数的原型，通过constructor指向构造函数。</p></blockquote> <h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，直至最顶级的原型对象Object.prototype，这就是<strong>原型链</strong>。</p> <h3 id="如何区分一个属性到底是基本的还是从原型中找到的呢"><a href="#如何区分一个属性到底是基本的还是从原型中找到的呢" class="header-anchor">#</a> 如何区分一个属性到底是基本的还是从原型中找到的呢</h3> <p>通过hasOwnProperty方法，特别是在for…in…循环(enumerable)中，一定要注意。</p> <h3 id="instanceof原理"><a href="#instanceof原理" class="header-anchor">#</a> instanceof原理</h3> <p>Instanceof的判断准则是：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。
<img src="%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95_files/18.jpg" alt="instance的逻辑"></p> <h3 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h3> <p>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变当我们需要一个属性的时， Javascript 引擎会先看当前对象中是否有这个属性，如果没有的,就会查找__proto__这条线来找。</p> <h2 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h2> <blockquote><p>函数是特殊的可执行对象,函数中存在这一个内部属性[[Scope]]（我们不能使用，供js引擎使用）.
函数被创建时，这个内部属性就会包含函数被创建的作用域中对象的集合，这个集合呈链式链接，被称为函数的作用域链。
作用域链上的每一个对象被称为可变对象（Variable Obejct），每一个可变对象都以键值对形式存在。
我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p></blockquote> <ul><li>由两部分组成:
<ul><li>[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO</li> <li>AO: 自身活动对象
如此 [[scopr]]包含[[scope]]，便自上而下形成一条 链式作用域。</li></ul></li></ul> <h3 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>它对应的[scope]</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 伪代码</span>
foo<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token constant">GO</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token operator">:</span> window <span class="token punctuation">,</span>
		window<span class="token operator">:</span> <span class="token operator">...</span> <span class="token punctuation">,</span>
		document<span class="token operator">:</span> <span class="token operator">...</span> <span class="token punctuation">,</span>
		<span class="token operator">...</span><span class="token operator">...</span>
		a<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token comment">// 预编译阶段还不知道a值是多少</span>
		<span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="scope-和执行上下文的区别"><a href="#scope-和执行上下文的区别" class="header-anchor">#</a> [[Scope]]和执行上下文的区别</h3> <ul><li>共同：都保存了函数作用域链</li> <li>[[Scope]]属性是函数创建时产生的，会一直存在</li> <li>而执行上下文在函数执行时产生，函数执行结束便会销毁</li></ul> <h3 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章</h3> <p><a href="https://blog.csdn.net/q1056843325/article/details/53086893" target="_blank" rel="noopener noreferrer">CSDN详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="执行上下文-ec-执行环境"><a href="#执行上下文-ec-执行环境" class="header-anchor">#</a> 执行上下文(EC)/执行环境</h2> <blockquote><p>执行上下文可以简单理解为一个对象【内部对象】</p></blockquote> <ul><li>它包含三个部分:
<ul><li>变量对象(VO)</li> <li>作用域链(词法作用域)</li> <li>this指向</li></ul></li> <li>它的类型:
<ul><li>全局执行上下文</li> <li>函数执行上下文</li> <li>eval执行上下文</li></ul></li> <li>代码执行过程:
<ul><li>创建 全局上下文 (global EC)</li> <li>全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层</li> <li>函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起</li> <li>函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行</li></ul></li></ul> <h3 id="特点-2"><a href="#特点-2" class="header-anchor">#</a> 特点</h3> <ul><li>它定义了一个函数执行时的环境</li> <li>函数每次执行时的执行环境独一无二</li> <li>多次调用函数就多次创建执行环境</li> <li>并且函数执行完毕后，执行环境就会被销毁</li> <li>执行环境有自己的作用域链，用于解析标识符</li></ul> <h3 id="变量对象"><a href="#变量对象" class="header-anchor">#</a> 变量对象</h3> <p>变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 变量和函数声明(不包含函数表达式)。</p> <blockquote><p>活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。</p></blockquote> <h3 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h3> <p>执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 变量和函数的作用范围。可分为 块级作用域 和 函数作用域。（js引擎根据名称查找变量的一套规则）</p> <ul><li>特性:
<ul><li>声明提前: 一个声明在函数体内都是可见的, 函数优先于变量</li> <li>非匿名自执行函数，函数变量为 只读 状态，无法修改</li></ul></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果去掉foo，打印的就是10</span>
    foo <span class="token operator">=</span> <span class="token number">10</span>  <span class="token comment">// 由于foo在函数中只为可读，因此赋值无效</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 

<span class="token comment">// 结果打印：  ƒ foo() { foo = 10 ; console.log(foo) }</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <blockquote><p>闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。</p></blockquote> <h3 id="特点-3"><a href="#特点-3" class="header-anchor">#</a> 特点：</h3> <ul><li>函数内再嵌套函数</li> <li>内部函数可以引用外层的参数和变量</li> <li>参数和变量不会被垃圾回收机制回收</li> <li>优点：能够实现封装和缓存等</li> <li>缺点：消耗内存、使用不当会内存溢出，</li> <li>解决方法：在退出函数之前，将不使用的局部变量全部删除</li></ul> <h2 id="this的取值-分五种情况"><a href="#this的取值-分五种情况" class="header-anchor">#</a> this的取值, 分五种情况</h2> <ol><li>构造函数，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象</li> <li>函数作为对象的一个属性，如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	name<span class="token operator">:</span> <span class="token string">'aa'</span><span class="token punctuation">,</span>
	<span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="3"><li>函数用call或者apply调用, 当一个函数被call和apply调用时，this的值就取传入的对象的值。</li> <li>全局 &amp; 调用普通函数, 在全局环境下，this永远是window
<img src="%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95_files/19.jpg" alt="特例"></li> <li>监听事件回调函数中的this, 指向触发这个事件的对象，特殊的是， IE 中的 attachEvent 中的this 总是指向全局对象 Window</li></ol> <h2 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="header-anchor">#</a> new操作符具体干了什么呢?</h2> <ul><li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</li> <li>属性和方法被加入到 this 引用的对象中</li> <li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li></ul> <h2 id="commonjs-规范"><a href="#commonjs-规范" class="header-anchor">#</a> commonjs 规范</h2> <ul><li>exports = module.exports</li> <li>exports</li> <li>module</li> <li>require</li></ul> <h2 id="export和export-default的区别"><a href="#export和export-default的区别" class="header-anchor">#</a> export和export default的区别？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span>  xxx
<span class="token keyword">import</span> xxx <span class="token keyword">from</span> <span class="token string">'./'</span>

<span class="token keyword">export</span> xxx
<span class="token keyword">import</span> <span class="token punctuation">{</span>xxx<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="js有哪些方法定义对象"><a href="#js有哪些方法定义对象" class="header-anchor">#</a> JS有哪些方法定义对象</h2> <ul><li>对象字面量： var obj = {};</li> <li>构造函数： var obj = new Object();</li> <li>Object.create(): var obj = Object.create(Object.prototype);</li></ul> <h2 id="如何通过js判断一个数组"><a href="#如何通过js判断一个数组" class="header-anchor">#</a> 如何通过JS判断一个数组</h2> <ol><li>instanceof  (arr instanceof Array)   ifrmae不行（iframe.createElement（'script'）instanceof Element）</li> <li>isArray (Array.isArray([]) //true)</li> <li>constructor (arr.constructor == Array; //true)</li> <li>Object.prototype  (Object.prototype.toString.call([]) == '[object Array]')</li> <li>Array.prototype.isPrototypeOf(obj)</li></ol> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <ul><li>jsonp</li> <li>cors</li></ul> <blockquote><p>参考掘金收藏文章，完善</p></blockquote> <h2 id="参考文章-2"><a href="#参考文章-2" class="header-anchor">#</a> 参考文章</h2> <p><a href="https://juejin.cn/post/6844903776512393224#heading-20" target="_blank" rel="noopener noreferrer">中高级<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://juejin.cn/post/6940945178899251230" target="_blank" rel="noopener noreferrer">2021<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/other/interview-js.html#讲讲js的数据类型" class="sidebar-link reco-side-讲讲js的数据类型" data-v-70334359>讲讲JS的数据类型？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#_7-种原始类型" class="sidebar-link reco-side-_7-种原始类型" data-v-70334359>7 种原始类型</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#_2-种结构类型" class="sidebar-link reco-side-_2-种结构类型" data-v-70334359>2 种结构类型</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#symbol类型" class="sidebar-link reco-side-symbol类型" data-v-70334359>Symbol类型</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#symbol函数可以接受一个字符串作为参数" class="sidebar-link reco-side-symbol函数可以接受一个字符串作为参数" data-v-70334359>Symbol函数可以接受一个字符串作为参数</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#如果-symbol-的参数是一个对象" class="sidebar-link reco-side-如果-symbol-的参数是一个对象" data-v-70334359>如果 Symbol 的参数是一个对象</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#symbol-类型转化" class="sidebar-link reco-side-symbol-类型转化" data-v-70334359>Symbol 类型转化</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#symbol作为属性名被遍历" class="sidebar-link reco-side-symbol作为属性名被遍历" data-v-70334359>Symbol作为属性名被遍历</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#异步编程实现方式" class="sidebar-link reco-side-异步编程实现方式" data-v-70334359>异步编程实现方式</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#找到a节点的父节点下的所有子节点" class="sidebar-link reco-side-找到a节点的父节点下的所有子节点" data-v-70334359>找到A节点的父节点下的所有子节点</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#encodeuri和encodeuricomponent的比较" class="sidebar-link reco-side-encodeuri和encodeuricomponent的比较" data-v-70334359>encodeURI和encodeURIComponent的比较</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#事件循环【event-loop】" class="sidebar-link reco-side-事件循环【event-loop】" data-v-70334359>事件循环【Event Loop】</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#event-loop是什么" class="sidebar-link reco-side-event-loop是什么" data-v-70334359>Event Loop是什么？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#为什么有event-loop" class="sidebar-link reco-side-为什么有event-loop" data-v-70334359>为什么有Event Loop？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#任务分为两类" class="sidebar-link reco-side-任务分为两类" data-v-70334359>任务分为两类</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#执行顺序测试题" class="sidebar-link reco-side-执行顺序测试题" data-v-70334359>执行顺序测试题</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#执行步骤" class="sidebar-link reco-side-执行步骤" data-v-70334359>执行步骤：</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#代码解析" class="sidebar-link reco-side-代码解析" data-v-70334359>代码解析：</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#那怎么知道主线程执行栈为空呢" class="sidebar-link reco-side-那怎么知道主线程执行栈为空呢" data-v-70334359>那怎么知道主线程执行栈为空呢？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#加入async的执行顺序测试题" class="sidebar-link reco-side-加入async的执行顺序测试题" data-v-70334359>加入async的执行顺序测试题</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#宏任务与微任务【异步任务】" class="sidebar-link reco-side-宏任务与微任务【异步任务】" data-v-70334359>宏任务与微任务【异步任务】</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#在event-loop中-每一次tick任务的执行顺序" class="sidebar-link reco-side-在event-loop中-每一次tick任务的执行顺序" data-v-70334359>在Event Loop中，每一次tick任务的执行顺序</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#有哪些是宏任务-macrotask-queue" class="sidebar-link reco-side-有哪些是宏任务-macrotask-queue" data-v-70334359>有哪些是宏任务（macrotask queue）</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#有哪些是微任务-microtask-queue" class="sidebar-link reco-side-有哪些是微任务-microtask-queue" data-v-70334359>有哪些是微任务（microtask queue）</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#repaint-重绘-和-reflow-回流" class="sidebar-link reco-side-repaint-重绘-和-reflow-回流" data-v-70334359>repaint（重绘）和 reflow（回流）</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#基本上能引起reflow的主要有几个原因" class="sidebar-link reco-side-基本上能引起reflow的主要有几个原因" data-v-70334359>基本上能引起reflow的主要有几个原因</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#reflow影响性能-优化方法如下" class="sidebar-link reco-side-reflow影响性能-优化方法如下" data-v-70334359>reflow影响性能，优化方法如下</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#说一下继承的几种方式及优缺点" class="sidebar-link reco-side-说一下继承的几种方式及优缺点" data-v-70334359>说一下继承的几种方式及优缺点？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#原型链继承" class="sidebar-link reco-side-原型链继承" data-v-70334359>原型链继承</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#借用-盗用-构造函数继承" class="sidebar-link reco-side-借用-盗用-构造函数继承" data-v-70334359>借用/盗用 构造函数继承</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#组合继承-组合原型链继承和借用构造函数继承-常用" class="sidebar-link reco-side-组合继承-组合原型链继承和借用构造函数继承-常用" data-v-70334359>组合继承（组合原型链继承和借用构造函数继承）（常用）</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#寄生式继承" class="sidebar-link reco-side-寄生式继承" data-v-70334359>寄生式继承</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#寄生组合式继承-常用" class="sidebar-link reco-side-寄生组合式继承-常用" data-v-70334359>寄生组合式继承（常用）</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#原型式继承-就是对象浅拷贝-object-create方法" class="sidebar-link reco-side-原型式继承-就是对象浅拷贝-object-create方法" data-v-70334359>原型式继承，就是对象浅拷贝，Object.create方法</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#javascript原型-原型链-有什么特点" class="sidebar-link reco-side-javascript原型-原型链-有什么特点" data-v-70334359>JavaScript原型，原型链 ? 有什么特点？</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#原型prototype" class="sidebar-link reco-side-原型prototype" data-v-70334359>原型prototype</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#实例" class="sidebar-link reco-side-实例" data-v-70334359>实例</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#原型链" class="sidebar-link reco-side-原型链" data-v-70334359>原型链</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#如何区分一个属性到底是基本的还是从原型中找到的呢" class="sidebar-link reco-side-如何区分一个属性到底是基本的还是从原型中找到的呢" data-v-70334359>如何区分一个属性到底是基本的还是从原型中找到的呢</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#instanceof原理" class="sidebar-link reco-side-instanceof原理" data-v-70334359>instanceof原理</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#特点" class="sidebar-link reco-side-特点" data-v-70334359>特点</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#作用域链" class="sidebar-link reco-side-作用域链" data-v-70334359>作用域链</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#例子" class="sidebar-link reco-side-例子" data-v-70334359>例子</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#scope-和执行上下文的区别" class="sidebar-link reco-side-scope-和执行上下文的区别" data-v-70334359>[[Scope]]和执行上下文的区别</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#参考文章" class="sidebar-link reco-side-参考文章" data-v-70334359>参考文章</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#执行上下文-ec-执行环境" class="sidebar-link reco-side-执行上下文-ec-执行环境" data-v-70334359>执行上下文(EC)/执行环境</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#特点-2" class="sidebar-link reco-side-特点-2" data-v-70334359>特点</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#变量对象" class="sidebar-link reco-side-变量对象" data-v-70334359>变量对象</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#作用域" class="sidebar-link reco-side-作用域" data-v-70334359>作用域</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#闭包" class="sidebar-link reco-side-闭包" data-v-70334359>闭包</a></li><li class="level-3" data-v-70334359><a href="/other/interview-js.html#特点-3" class="sidebar-link reco-side-特点-3" data-v-70334359>特点：</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#this的取值-分五种情况" class="sidebar-link reco-side-this的取值-分五种情况" data-v-70334359>this的取值, 分五种情况</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#new操作符具体干了什么呢" class="sidebar-link reco-side-new操作符具体干了什么呢" data-v-70334359>new操作符具体干了什么呢?</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#commonjs-规范" class="sidebar-link reco-side-commonjs-规范" data-v-70334359>commonjs 规范</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#export和export-default的区别" class="sidebar-link reco-side-export和export-default的区别" data-v-70334359>export和export default的区别？</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#js有哪些方法定义对象" class="sidebar-link reco-side-js有哪些方法定义对象" data-v-70334359>JS有哪些方法定义对象</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#如何通过js判断一个数组" class="sidebar-link reco-side-如何通过js判断一个数组" data-v-70334359>如何通过JS判断一个数组</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#跨域" class="sidebar-link reco-side-跨域" data-v-70334359>跨域</a></li><li class="level-2" data-v-70334359><a href="/other/interview-js.html#参考文章-2" class="sidebar-link reco-side-参考文章-2" data-v-70334359>参考文章</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.de4e8d83.js" defer></script><script src="/assets/js/3.c95393d0.js" defer></script><script src="/assets/js/1.4877e3be.js" defer></script><script src="/assets/js/49.11fdfc33.js" defer></script>
  </body>
</html>
